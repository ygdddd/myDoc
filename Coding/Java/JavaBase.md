# Java 基础

J2SE：Java SE，支持桌面级应用的Java平台，提供核心API
J2EE：Java EE，面向开发企业的解决方案，针对Web应用开发，包含如Servlet，JSP等
J2ME：Java ME，支持Java在移动端运行的平台，精简API并加入针对移动端的支持

## Java 特性

1. 面向对象（OOP）「[封装](#封装-encapsulation)、[继承](#继承-extend)、[多态](#多态-polymorphic)」
2. 健壮性，强类型语言，包括强类型机制、异常处理、垃圾回收机制保障
3. 跨平台，Java代码无关平台，通过JVM、JRE来满足不同平台运行要求
4. Java是解释性语言，即不能直接运行，需要解释器执行；（C/C++可以直接被机器执行）

### Java 跨平台运行

1. JVM Java virtual machine Java虚拟机，具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器，包含在JDK中
2. 不同平台，有不同的虚拟机
3. 编译：Javac（Java complier）将.java编译成.class（JVM识别的字节码文件），再用Java将.class装载到JVM执行
4. JVM屏蔽了不同平台的执行机制，实现跨平台


- JDK(Java Development Kit)：单独给开发人员使用的工具，包括JRE
- JRE(Java Runtime Environmen)：包括JVM和核心类库，运行程序只需要JRE
- JDK = JRE + Java开发工具
- JRE = JVM + Java核心类库

JVM结构：JVM包含栈、堆、方法区

### Java文件中的Class

1. 一个源文件最多一个public类，其他类数量不限，其他类中也可以运行main方法
2. 编译时一个类对应一个.class文件
3. 如果Java文件包含public类，则文件名必须和public类名相同

API：Application Programming Interface
- [中文API参考文档](https://www.matools.com/api)

## 变量与数据类型

概念：内存开辟一块空间来存储变量的值，并使用一个索引来指向这块空间
该区域有自己的索引【变量名】和数据类型

### Java中基本数据类型占用空间大小

|   TYPE  |    SIZE   |      RANGE      |  BOX TYPE |
|:-------:|:---------:|:---------------:|:---------:|
| byte    | 1 Byte    | -2^7 ~ 2^7-1    | Byte      |
| short   | 2 Byte    | -2^15 ~ 2^15-1  | Short     |
| int     | 4 Byte    | -2^31 ~ 2^31-1  | Integer   |
| long    | 8 Byte    | -2^63 ~ 2^63-1  | Long      |
| float   | 4 Byte    |                 | Float     |
| double  | 8 Byte    |                 | Double    |
| char    | 2 Byte    |                 | Character |
| boolean | 1or4 Byte | true `OR` false | Boolean   |

- Java是强类型语言，需要显式指定数据类型
- 1 Byte = 8 bits
- long数据的值后要带`l`或者`L`
- float数据的值后要带`f`或者`F`
- boolean不可以用0或非0代替
- char的本质是整数(码值)，输出对应的unicode字符
- 常见编码(英｜汉字节)：ASCII，unicode(2｜2)，utf-8(1｜3），gbk(1｜2)
- [unicode在线转换](http://tool.chinaz.com/Tools/Unicode.aspx)
- （char和short）和byte不会自动转换，计算时总是转换为int

### String和基本数据类型

String-基本类型： (X类型)包装类.parseX(String)
基本类型-String： BaseType + ""

## 运算符

算术运算符：+ - * / % ++ --
- 除以的时候，右边先运算，再赋值到左边
- 取模公式：a % b = a - a / b * b

关系运算符：== != < > <= >= instanceof

逻辑运算符：& | && || ! ^ （返回值都为boolean）
- 短路与&& 逻辑与&：短路与判断时，第一个为false则直接返回；逻辑与必须全部判断完
- 短路或|| 逻辑或|：短路或判断时，第一个为true则直接返回；逻辑或必须全部判断完
- 逻辑异或^：相同时false，不同时true

三元运算符： 条件 ? a : b
- 条件为true结果为a， 条件为false结果b

赋值运算符：= += -= *= /= %=
- a += b -> a = a + b
- 复合赋值运算符会自动进行类型转换

## 标识符

变量、方法、类等命名时使用的字符序列为标识符（所有自己命名的）
- 由字母、数字、_或$组成
- 数字不能开头
- 不能使用关键字/保留字，但可以包含（关键字：public, class, static...）

### 标识符规范

Package: 多单词组成时所有字母小写

Class & Interface: 所有单词首字母大写（大驼峰）

Variable & Method: 第一个单词首字母小写，其余首字母大写（小驼峰）

Constant: 所有字母大写，_连接

### 键盘输入

``` Java
//使用java.util.Scanner
//一个使用正则表达式解析基本类型和字符串的文本扫描器
import java.util.Scanner;

Scanner inputScanner = new Scanner(System.in);
int number = inputScanner.nextInt();
String str = inputScanner.next();
```

## 进制

二进制：0，1，开头0B，0b
- 二进制转八进制：先在高位补0直到位数是3的倍数，每`3`位转换一位八进制数字
- 二进制转十六进制：先在高位补0直到位数是4的倍数，每`4`位转换一位十六进制数字
- 八进制转二进制：每位转换3个二进制数字
- 十六进制转二进制：每位转换4个二进制数字

八进制：0-8，开头0 

十六进制：0-9，a-f，0x或0X开头

十进制：0-9
- N进制转十进制：每位数字乘以每位的次方值，再相加。
- 十进制转N进制：不断除以`n`，直到商为0，然后将每步的余数倒过来。

### 位运算

1. 原码：有符号二进制码，最高位为符号位，正数0，负数1
2. 反码：正数反码等于原码，负数的反码 = 除符号位以外，原码按位取反
3. 补码：正数补码等于原码，负数的补码 = 反码 + 1

- 0的反码，补码都为0
- Java没有无符号数
- 计算机运行的时候，都是以补码的方式来运算的，结果再以原码的方式展示
- 原->补（统一计算符号），补->原（还原符号）

位运算符：&，|，^，~, >>, <<, >>>

- 算术右移`>>`:低位溢出，符号位不变，高位补符号位（/2）
- 算术左移`<<`:符号位不变，低位补0（*2）
- 逻辑（无符号）右移`>>>`:低位溢出，高位补0

## 分支控制

1. 顺序控制：先定义后引用，不涉及判断
2. 分支控制：if if-else else
3. switch：switch(表达式) case(值): break default
    - case执行完不会主动退出，如果没有break，会跳过下一个case的判断，穿透执行下一个case的语句，直到break
    - 表达式和case值的类型应该相同，或允许自动转换后比较
    - 表达式返回值必须是：byte short int char enum String中的一种
    - case值只能是常量
4. 循环控制：for(初始化循环变量; 循环条件; 循环变量迭代) { 循环操作; }
    - 循环变量迭代在循环操作之后执行
    - 可以初始化、迭代多个循环变量，也可以在循环外执行

5. 循环控制：(初始化;) while(循环条件){循环操作; 循环变量迭代;}

6. 循环控制：(初始化;) do{循环操作; 循环变量迭代;}while(循环条件);
    - 循环条件放在最后，即至少会执行一次

7. 多重循环控制：for / while / do while

8. break可以终止某个循环
    - 可以通过标签来指定终止哪一层循环，若没有标签则默认退出最近一层循环。
    - 尽量不使用标签，会影响可读性
    ```Java
    //在{}前加上标签名
    label1: 
    for(;;){
        label2:
        for(;;){
            if(){
                break label1;
            }
        }
    }
    ```

9. continue跳过此次循环，执行下一次循环
    - 可以通过标签指定跳过哪一层的循环，若没有标签则默认跳过最近一层循环。
    - 尽量不使用标签，影响可读性


10. return跳出当前方法（main方法的return直接退出程序）

## 数组Array

数组的定义：引用类型，可以存放多个同一类型的数据

数组的长度：array.length

数组中元素可以指定为任何类型，包括基本类型和引用类型，不能混用

数组属于引用类型，数组型数据是对象。

直接赋值整个数组在默认情况下是引用传递

数组创建时元素默认值：
| type | default |
|:----:|:-------:|
| int | 0|
| short | 0 |
| byte | 0 |
| long | 0 |
| float | 0.0 |
| double| 0.0 |
| char| \u0000 |
| boolean | false |
|String | null|

```Java
    //定义数组的多种方式，下标从0开始
    //type[] arr 等价 type arr[]
    type[] arr1 = {1, 2, 3, 5}; //静态初始化，直接填充数据元素
    
    //等价于先声明，再分配
    type[] arr2 = new type[len];//动态初始化，长度为len
```

### 二维数组

相当于一维数组的每个元素也是一维数组，使用两层下标访问特定元素。

共三种声明方式
- type[][] name
- type name[][]
- type[] name[]

```Java
    type[][] _2Darr1 = {{1}, {2,3}, {1,3,5}}; //静态初始化，直接填充数据元素
    
    type[][] _2Darr2 = new type[amount][size];//动态初始化，有amount个一维数组，每个一维数组的大小为size
```
## 排序

内部排序：将所有需要处理的数据都加载到内存中进行排序
- 交换排序
- 选择排序
- 插入排序

外部排序：数据量过大导致无法全部加载到内存中，需要借助外部存储进行排序
- 合并排序
- 直接合并排序

## 查找

顺序查找：

二分查找：

# 面向对象 Object Oriented Programming

## 类与对象

类即数据类型，是概念性的模板（包含某类实体提取到的所有属性以及行为）

对象即某个类的实例，属于具体的事物（具有特异化的属性以及通用的行为）

```Java
//创建类
class DemoCLoas{
    modifier type attr1; // 定义属性、成员变量、field：访问修饰符 类型 名称
    ...
    modifier type attrN; // 属性不赋值时也存在默认值
    DemoClass(){

    }
    //method(形参列表){方法体}
    modifier type method1(){
        return;
    }
}

```

JVM的内存中，对象的引用存在`栈`中，`栈`的地址指向`堆`的一块内存，`堆`保存成员变量中基本类型的值和`引用类型的地址`，引用类型的地址指向`方法区`中`常量池`的一块内存

### 方法 Method

Java中方法传入形参为浅拷贝，仅传入栈中`对象的引用`或者基本类型的值，方法中修改基本类型的值对于外部的实参无影响，但是修改引用类型的数据会影响堆/方法区中的参数。

#### 方法的重载 Overload

重载：在同一个类中，允许存在多个同名，但形参列表不同的方法，会自动根据传入的参数数量和类型匹配。
- 返回类型可以不同，形参列表必须不同
- 减轻了起名和记名的负担

可变参数：Java允许将同一个类中多个同名同功能，但是参数个数不同的方法，封装成一个方法。
- 接收的数量可以是0至多个
- 可变参数的实参可以为数组，本质就是数组
- 可变参数和基本类型参数同时存在，可变参数必须在最后
- 一个形参列表只能同时存在一个可变参数

```Java
    //类型后跟`...`表示可以接收不定数量个该类型参数
    modifier type name(type... name){
        //name->视为数组->name[]
    }
```

全局变量：类中的属性/成员变量，作用域为整个类，可以不赋值，有默认值；

局部变量：方法/代码块中定义的变量或方法的形参（可以认为是除全局变量外的所有变量），必须赋值后使用，无默认值

1. 属性和局部变量可以重名，都存在时优先访问局部变量（就近）
2. 局部变量在方法/代码块结束时就销毁，属性在对象销毁时才销毁
3. 只有全局变量可被其他类调用
4. 只有全局变量可以加修饰符

#### 构造器 Constructor

构造器用于新对象的初始化。
- 构造方法名称和类名相同
- 构造器可以重载
- 创建对象时，系统自动调用构造器初始化对象
- 没有返回值，可以带修饰符

如果没有显式定义构造器，系统会自动生成一个默认无参构造器「Name(){}」
- 定义构造器后会覆盖该默认无参构造器
- 定义后还需要无参构造器需要显式定义

```Java
class Name(){
    modifier Name(){

    }

    modifier Name(type name){

    }
}
```

对象创建流程「new Class("Info", 1);」
1. 方法区加载类信息（.calss文件）
2. 堆中开辟空间（地址）存放属性，先进行默认初始化（String 类型为null）
3. 完成显式初始化，即定义时分配的值
4. 运行指定的构造方法（String指向常量池中的内容）

对象的this关键字：JVM会给每个对象分配this，指向当前对象
- this是一个引用，指向当前对象的堆空间地址
- this.hashCode()方法：每个对象的唯一标识码，是根据对象的内部地址转换成一个整数来实现的。
- this可以通过「this.var / this.fun() / this()」访问本类的属性，方法，构造器
- this访问构造器只能在构造器中使用，且this()必须在第一条语句
- 可以区分属性和局部变量
- 类定义的外部无法使用this


```Java
    public class C{
        type var1;
        type var2;

        C(type var1, type var2){
            this.var1 = var1; //同名时默认使用局部变量
            this.var2 = var2; //使用this指向成员变量（类似外部访问）
        }
    }
```

## 包 Package

包的本质就是创建不同的文件夹来保存类文件
作用
1. 区分相同名字的类
2. 在类数量较多时便于管理
3. 控制访问范围（modifier）
4. 使用「package com.xxx;」声明文件所在的包

命名规则：只能包含数字，字母，下划线，小圆点，不能用数字开头，不能是关键字或者保留字。一般是小写字母+圆点。「com.company.project.module」

## 访问修饰符

四种修饰符（对类、方法、属性都适用）:
| 访问级别 |修饰符|同类|同包|子类|不同包 |
| :----:|:----:|:----:|:----:|:----:|:----:|
| 公开 |public|√|√|√|√ |
| 受保护|protected|√|√|√|X|
| 默认 |无修饰符|√|√|X|X|
| 私有 |private|√|X|X|X|

1. 四种修饰符都可以修饰类中的属性和方法
2. 类本身只能无修饰符或被public修饰
3. 子类

### 封装 Encapsulation

封装就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的方法才能对数据进行访问或操作。

好处：
- 隐藏实现的细节
- 可以对数据进行验证，保证安全合理

步骤：
1. 将属性私有化（避免直接修改）
2. 提供公共的set方法，用于判断赋值的合理性并赋值
3. 提供一个公共的get方法，用于获取某个数据的值

```Java
public void setArr(type arr){
    this.arr = arr;
}
```

### 继承 Extend

继承主要解决代码复用。当多个类存在相同的属性和方法是，可以从这些类中抽象出父类，父类中定义相同的属性和方法，子类只需要通过extends类声明继承父类。
    
1. 子类会自动拥有父类定义的属性和方法
2. 父类又叫超类，基类
3. 子类又叫派生类

```Java
class Father{
    // 共有的属性和方法
}

class Child1 extends Father{
    //特有的属性和方法
    //重写@Override
}
```

1. 子类继承所有的属性和方法，但子类不能直接访问父类的私有属性，只能通过其公共方法访问
2. 创建子类对象时，不管子类使用哪个构造器，`默认总会调用父类的无参构造器`；如果父类不提供无参构造器，则需要在子类的构造器中使用`super`指定使用父类的哪个构造器完成父类的初始化
3. 需要调用父类的某个构造器，需要在子类显式调用
4. super()需要放在构造器第一行，因此一个构造器中super()不能和this()同时存在
5. Java中所有类都是`Object`类的子类；父类构造器的调用不限于直接父类，会一直追溯到Object类
6. 子类最多只能显式继承一个父类，即`单继承机制`；不能滥用继承，继承必须满足`is-a`的关系
---
继承中的加载机制：
1. 先从显式调用的类（子类）追溯到顶层类，然后从Object开始从上到下依次加载类到`方法区`，直到显式调用的类
2. 在堆中分配对象空间，在对象空间中为每个被继承的类依次分配空间存放`属性`，并给每个属性赋默认值
3. 依次调用构造器方法，完成属性的初始化

#### super关键字

super代表父类的引用，用于访问父类的属性、方法、构造器。
- 无法访问父类中被private修饰的属性和方法
- 子类和父类有重名成员时，访问父类中的成员，必须用super来访问，不重名时this和super的效果是一样的
- super的访问不限于直接父类，如果父类的父类和本类有同名成员，也可以使用super访问；
- 如果多个父类中都有同名的成员，super遵循就近原则
---
访问子类中的成员（属性/方法）
1. 先看子类是否有该成员，有且允许访问则返回
2. 如果子类没有该成员，则向上检查父类是否有该成员，有且允许访问则返回
3. 如果父类没有该成员，则一直向上检查直到Object类

```Java
//子类访问不重名的成员时，三种访问方式等效
//子类和父类有重名的成员时，用super会跳过子类，直接找到父类的方法
method();
this.method();  //从本类开始找
super.method(); //跳过本类，直接从父类开始查找
```

this关键字和super关键字区别
|操作|this|super|
|:---|:---|:---|
|访问属性|从本类开始查找属性|从父类开始查找属性|
|调用方法|从本类开始查找方法|从父类开始查找方法|
|调用构造器|调用本类构造器，必须在首行|调用父类构造器，必须在首行|
|特殊|表示当前对象|子类中访问父类对象|

#### 方法重写 Override

方法重写：子类中某个方法和父类某个方法的名称、返回类型、参数列表一样
- 子类方法的参数列表和方法名称需要父类方法完全一样
- 子类方法的返回类型和父类方法一样，或者是父类方法返回类型的子类
    ```Java
        public Object method(){}    //父类
        public String method(){}    //子类
    ```
- 子类方法不能缩小父类方法的访问权限 pub > pro > def > pri

### 多态 polymorphic

方法或对象具有多种形态，多态是建立在封装和继承基础上的

方法的多态：重写和重载体现多态

对象的多态：
1. 一个对象的编译类型和运行类型可以不一致
2. 编译类型在定义对象时确定，不能改变
3. 运行类型是可以变化的
4. 定义对象时，「=」左边是编译类型，右边是运行类型

属性的值只和编译类型有关，不存在重写的操作

---
多态的注意事项和细节：
- 前提：两个对象存在继承关系

向上转型：
1. 本质是父类的引用指向子类的对象（即`向上转型`）Father father = new Son();
2. 可以调用父类中所有成员（遵守访问权限）
3. 不能调用子类的特有成员，运行时调用子类的具体实现（编译阶段能调用哪些成员由编译类型决定）

向下转型：
1. 使用强制类型转换 Son son = (Son) father;
2. 只能强制转换父类的引用，不能强制转换父类的对象
3. 父类的引用必须指向当前目标类型的对象
4. 可以调用子类类型中所有的成员

obj instanceOf Class：比较操作符 `instanceOf`，用于判断obj对象的运行类型是否是Class类型或其子类

动态绑定机制：
1. 调用对象方法时，该方法会和该对象的内存地址/运行类型绑定
2. 调用对象属性时，属性没有动态绑定机制，哪里声明哪里使用
---

多态的应用

1. 多态数组：数组的定义类型为父类类型，里面保存的元素类型为子类类型
```Java
Father[] array = new Father[n];
Father[0] = new Son();
Father[1] = new Son2();
```
2. 多态参数：方法定义的形参类型为父类类型，实参类型允许为子类类型
```Java
class OBJ {
    public void method(Father father){
        ...
    }
}
public static void main(String args[]){
    OBJ obj = new obj();
    obj.method(son);
}
```

### Object类常用方法

boolean equals(Object obj)
> 指示其他某个对象是否与该对象相等
比较运算符「==」和equals的对比
- ==既可以判断基本类型也可以判断引用类型
    1. 如果判断基本类型，判断值是否相等
    2. 如果判断引用类型，判断地址是否相等，即是否为同一个对象
- equals只能判断引用类型，默认判断地址是否相等(==)
    - 通常在子类中会根据需求重写equals方法

int hashCode()
> 返回对象的哈希码值
1. 提高具有哈希结构容器的效率
2. 两个引用，如果指向同一个对象，哈希值相同；指向不同对象，则哈希值不同
3. 哈希值根据地址计算得出，但是哈希值不等价于地址

String toString()
返回对象的字符串表示，默认返回全类名+@+哈希值的十六进制

protected void finalize()
> 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法
1. 对象被回收时，系统自动调用该对象的finalize方法。可以重写该方法执行释放资源的操作（默认无操作）。
2. 当某个对象没有任何引用时，则JVM就认为这个对象是垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁前会先调用finalize方法。
3. 垃圾回收机制的调用由系统控制，可以通过System.gc()来主动触发。

Class<?> getClass()
> 返回Object的运行时类